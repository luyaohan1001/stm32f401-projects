ARM GAS  /tmp/cckCRgnX.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"BTLE.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.swapbuf,"ax",%progbits
  18              		.align	1
  19              		.global	swapbuf
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	swapbuf:
  26              	.LFB131:
  27              		.file 1 "Src/BTLE.c"
   1:Src/BTLE.c    **** /*
   2:Src/BTLE.c    ****  * Copyright (C) 2013 Florian Echtler <floe@butterbrot.org>
   3:Src/BTLE.c    ****  *
   4:Src/BTLE.c    ****  * This program is free software; you can redistribute it and/or
   5:Src/BTLE.c    ****  * modify it under the terms of the GNU General Public License
   6:Src/BTLE.c    ****  * version 3 as published by the Free Software Foundation.
   7:Src/BTLE.c    **** */
   8:Src/BTLE.c    **** 
   9:Src/BTLE.c    **** #include <BTLE.h>
  10:Src/BTLE.c    **** 
  11:Src/BTLE.c    **** #define min(x,y) ( ((x) < (y)) ? (x) : (y) ) 
  12:Src/BTLE.c    **** #define max(x,y) ( ((x) > (y)) ? (x) : (y) ) 
  13:Src/BTLE.c    **** 
  14:Src/BTLE.c    **** const uint8_t channel[3]   = {37,38,39};  // logical BTLE channel number (37-39)
  15:Src/BTLE.c    **** const uint8_t frequency[3] = { 2,26,80};  // physical frequency (2400+x MHz)
  16:Src/BTLE.c    **** 
  17:Src/BTLE.c    **** 
  18:Src/BTLE.c    **** // This is a rather convoluted hack to extract the month number from the build date in
  19:Src/BTLE.c    **** // the __DATE__ macro using a small hash function + lookup table. Since all inputs are
  20:Src/BTLE.c    **** // const, this can be fully resolved by the compiler and saves over 200 bytes of code.
  21:Src/BTLE.c    **** #define month(m) month_lookup[ (( ((( (m[0] % 24) * 13) + m[1]) % 24) * 13) + m[2]) % 24 ]
  22:Src/BTLE.c    **** const uint8_t month_lookup[24] = { 0,6,0,4,0,1,0,17,0,8,0,0,3,0,0,0,18,2,16,5,9,0,1,7 };
  23:Src/BTLE.c    **** 
  24:Src/BTLE.c    **** 
  25:Src/BTLE.c    **** // change buffer contents to "wire bit order"
  26:Src/BTLE.c    **** void swapbuf( uint8_t len ) {
  28              		.loc 1 26 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
ARM GAS  /tmp/cckCRgnX.s 			page 2


  33              	.LVL0:
  34 0000 10B4     		push	{r4}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 4
  37              		.cfi_offset 4, -4
  38              	.LVL1:
  27:Src/BTLE.c    **** 
  28:Src/BTLE.c    ****   uint8_t* buf = (uint8_t*)&buffer;
  39              		.loc 1 28 0
  40 0002 1B4C     		ldr	r4, .L15
  29:Src/BTLE.c    **** 
  30:Src/BTLE.c    ****   while (len--) {
  41              		.loc 1 30 0
  42 0004 04E0     		b	.L2
  43              	.LVL2:
  44              	.L12:
  45              	.LBB2:
  31:Src/BTLE.c    **** 
  32:Src/BTLE.c    ****     uint8_t a = *buf;
  33:Src/BTLE.c    ****     uint8_t v = 0;
  34:Src/BTLE.c    **** 
  35:Src/BTLE.c    ****     if (a & 0x80) v |= 0x01;
  46              		.loc 1 35 0
  47 0006 0122     		movs	r2, #1
  48 0008 0AE0     		b	.L3
  49              	.LVL3:
  50              	.L10:
  36:Src/BTLE.c    ****     if (a & 0x40) v |= 0x02;
  37:Src/BTLE.c    ****     if (a & 0x20) v |= 0x04;
  38:Src/BTLE.c    ****     if (a & 0x10) v |= 0x08;
  39:Src/BTLE.c    ****     if (a & 0x08) v |= 0x10;
  40:Src/BTLE.c    ****     if (a & 0x04) v |= 0x20;
  41:Src/BTLE.c    ****     if (a & 0x02) v |= 0x40;
  42:Src/BTLE.c    ****     if (a & 0x01) v |= 0x80;
  43:Src/BTLE.c    **** 
  44:Src/BTLE.c    ****     *(buf++) = v;
  51              		.loc 1 44 0
  52 000a 2270     		strb	r2, [r4]
  53 000c 0134     		adds	r4, r4, #1
  54              	.LVL4:
  55              	.LBE2:
  30:Src/BTLE.c    **** 
  56              		.loc 1 30 0
  57 000e 0846     		mov	r0, r1
  58              	.LVL5:
  59              	.L2:
  60 0010 431E     		subs	r3, r0, #1
  61 0012 D9B2     		uxtb	r1, r3
  62              	.LVL6:
  63 0014 40B3     		cbz	r0, .L14
  64              	.LBB3:
  32:Src/BTLE.c    ****     uint8_t v = 0;
  65              		.loc 1 32 0
  66 0016 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
  67              	.LVL7:
  35:Src/BTLE.c    ****     if (a & 0x40) v |= 0x02;
  68              		.loc 1 35 0
ARM GAS  /tmp/cckCRgnX.s 			page 3


  69 0018 13F0800F 		tst	r3, #128
  70 001c F3D1     		bne	.L12
  33:Src/BTLE.c    **** 
  71              		.loc 1 33 0
  72 001e 0022     		movs	r2, #0
  73              	.L3:
  74              	.LVL8:
  36:Src/BTLE.c    ****     if (a & 0x20) v |= 0x04;
  75              		.loc 1 36 0
  76 0020 13F0400F 		tst	r3, #64
  77 0024 01D0     		beq	.L4
  36:Src/BTLE.c    ****     if (a & 0x20) v |= 0x04;
  78              		.loc 1 36 0 is_stmt 0 discriminator 1
  79 0026 42F00202 		orr	r2, r2, #2
  80              	.LVL9:
  81              	.L4:
  37:Src/BTLE.c    ****     if (a & 0x10) v |= 0x08;
  82              		.loc 1 37 0 is_stmt 1
  83 002a 13F0200F 		tst	r3, #32
  84 002e 01D0     		beq	.L5
  37:Src/BTLE.c    ****     if (a & 0x10) v |= 0x08;
  85              		.loc 1 37 0 is_stmt 0 discriminator 1
  86 0030 42F00402 		orr	r2, r2, #4
  87              	.LVL10:
  88              	.L5:
  38:Src/BTLE.c    ****     if (a & 0x08) v |= 0x10;
  89              		.loc 1 38 0 is_stmt 1
  90 0034 13F0100F 		tst	r3, #16
  91 0038 01D0     		beq	.L6
  38:Src/BTLE.c    ****     if (a & 0x08) v |= 0x10;
  92              		.loc 1 38 0 is_stmt 0 discriminator 1
  93 003a 42F00802 		orr	r2, r2, #8
  94              	.LVL11:
  95              	.L6:
  39:Src/BTLE.c    ****     if (a & 0x04) v |= 0x20;
  96              		.loc 1 39 0 is_stmt 1
  97 003e 13F0080F 		tst	r3, #8
  98 0042 01D0     		beq	.L7
  39:Src/BTLE.c    ****     if (a & 0x04) v |= 0x20;
  99              		.loc 1 39 0 is_stmt 0 discriminator 1
 100 0044 42F01002 		orr	r2, r2, #16
 101              	.LVL12:
 102              	.L7:
  40:Src/BTLE.c    ****     if (a & 0x02) v |= 0x40;
 103              		.loc 1 40 0 is_stmt 1
 104 0048 13F0040F 		tst	r3, #4
 105 004c 01D0     		beq	.L8
  40:Src/BTLE.c    ****     if (a & 0x02) v |= 0x40;
 106              		.loc 1 40 0 is_stmt 0 discriminator 1
 107 004e 42F02002 		orr	r2, r2, #32
 108              	.LVL13:
 109              	.L8:
  41:Src/BTLE.c    ****     if (a & 0x01) v |= 0x80;
 110              		.loc 1 41 0 is_stmt 1
 111 0052 13F0020F 		tst	r3, #2
 112 0056 01D0     		beq	.L9
  41:Src/BTLE.c    ****     if (a & 0x01) v |= 0x80;
ARM GAS  /tmp/cckCRgnX.s 			page 4


 113              		.loc 1 41 0 is_stmt 0 discriminator 1
 114 0058 42F04002 		orr	r2, r2, #64
 115              	.LVL14:
 116              	.L9:
  42:Src/BTLE.c    **** 
 117              		.loc 1 42 0 is_stmt 1
 118 005c 13F0010F 		tst	r3, #1
 119 0060 D3D0     		beq	.L10
  42:Src/BTLE.c    **** 
 120              		.loc 1 42 0 is_stmt 0 discriminator 1
 121 0062 42F08002 		orr	r2, r2, #128
 122              	.LVL15:
 123 0066 D0E7     		b	.L10
 124              	.LVL16:
 125              	.L14:
 126              	.LBE3:
  45:Src/BTLE.c    ****   }
  46:Src/BTLE.c    **** }
 127              		.loc 1 46 0 is_stmt 1
 128 0068 5DF8044B 		ldr	r4, [sp], #4
 129              	.LCFI1:
 130              		.cfi_restore 4
 131              		.cfi_def_cfa_offset 0
 132              	.LVL17:
 133 006c 7047     		bx	lr
 134              	.L16:
 135 006e 00BF     		.align	2
 136              	.L15:
 137 0070 00000000 		.word	buffer
 138              		.cfi_endproc
 139              	.LFE131:
 141              		.section	.text.begin,"ax",%progbits
 142              		.align	1
 143              		.global	begin
 144              		.syntax unified
 145              		.thumb
 146              		.thumb_func
 147              		.fpu fpv4-sp-d16
 149              	begin:
 150              	.LFB133:
  47:Src/BTLE.c    **** 
  48:Src/BTLE.c    **** /*
  49:Src/BTLE.c    **** // constructor
  50:Src/BTLE.c    **** BTLE( RF24* _radio ):
  51:Src/BTLE.c    ****   radio(_radio),
  52:Src/BTLE.c    ****   current(0)
  53:Src/BTLE.c    **** { }
  54:Src/BTLE.c    **** */
  55:Src/BTLE.c    **** 
  56:Src/BTLE.c    **** 
  57:Src/BTLE.c    **** // Simple converter from arduino float to a nRF_Float.
  58:Src/BTLE.c    **** // Supports values from -167772 to +167772, with two decimal places.
  59:Src/BTLE.c    **** nRF_Float 
  60:Src/BTLE.c    **** to_nRF_Float(float t) {
  61:Src/BTLE.c    ****   int32_t ret;
  62:Src/BTLE.c    ****   int32_t exponent = -2;
  63:Src/BTLE.c    ****   ret = ((exponent & 0xff) << 24) | (((int32_t)(t * 100)) & 0xffffff);
ARM GAS  /tmp/cckCRgnX.s 			page 5


  64:Src/BTLE.c    ****   return ret;
  65:Src/BTLE.c    **** }
  66:Src/BTLE.c    **** 
  67:Src/BTLE.c    **** // set BTLE-compatible radio parameters
  68:Src/BTLE.c    **** /*
  69:Src/BTLE.c    **** void begin( const char* _name ) {
  70:Src/BTLE.c    **** 
  71:Src/BTLE.c    ****   name = _name;
  72:Src/BTLE.c    ****   radio->begin();
  73:Src/BTLE.c    **** 
  74:Src/BTLE.c    ****   // set standard parameters
  75:Src/BTLE.c    ****   radio->setAutoAck(false);
  76:Src/BTLE.c    ****   radio->setDataRate(RF24_1MBPS);
  77:Src/BTLE.c    ****   radio->disableCRC();
  78:Src/BTLE.c    ****   radio->setChannel( frequency[current] );
  79:Src/BTLE.c    ****   radio->setRetries(0,0);
  80:Src/BTLE.c    ****   radio->setPALevel(RF24_PA_MAX);
  81:Src/BTLE.c    **** 
  82:Src/BTLE.c    ****   // set advertisement address: 0x8E89BED6 (bit-reversed -> 0x6B7D9171)
  83:Src/BTLE.c    ****   radio->setAddressWidth(4);
  84:Src/BTLE.c    ****   radio->openReadingPipe(0,0x6B7D9171);
  85:Src/BTLE.c    ****   radio->openWritingPipe(  0x6B7D9171);
  86:Src/BTLE.c    **** 
  87:Src/BTLE.c    ****   radio->powerUp();
  88:Src/BTLE.c    **** }
  89:Src/BTLE.c    **** */
  90:Src/BTLE.c    **** 
  91:Src/BTLE.c    **** 
  92:Src/BTLE.c    **** void begin( const char* _name ) {
 151              		.loc 1 92 0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 8
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155              	.LVL18:
 156 0000 70B5     		push	{r4, r5, r6, lr}
 157              	.LCFI2:
 158              		.cfi_def_cfa_offset 16
 159              		.cfi_offset 4, -16
 160              		.cfi_offset 5, -12
 161              		.cfi_offset 6, -8
 162              		.cfi_offset 14, -4
 163 0002 82B0     		sub	sp, sp, #8
 164              	.LCFI3:
 165              		.cfi_def_cfa_offset 24
  93:Src/BTLE.c    ****   
  94:Src/BTLE.c    ****   name = _name;
 166              		.loc 1 94 0
 167 0004 244B     		ldr	r3, .L19
 168 0006 1860     		str	r0, [r3]
  95:Src/BTLE.c    ****   // radio->begin();
  96:Src/BTLE.c    **** 
  97:Src/BTLE.c    ****   // set standard parameters
  98:Src/BTLE.c    ****   // radio->setAutoAck(false);
  99:Src/BTLE.c    ****   // radio->setDataRate(RF24_1MBPS);
 100:Src/BTLE.c    ****   // radio->disableCRC();
 101:Src/BTLE.c    ****   // radio->setChannel( frequency[current] );
 102:Src/BTLE.c    ****   // radio->setRetries(0,0);
ARM GAS  /tmp/cckCRgnX.s 			page 6


 103:Src/BTLE.c    ****   // radio->setPALevel(RF24_PA_MAX);
 104:Src/BTLE.c    **** 
 105:Src/BTLE.c    ****   // set advertisement address: 0x8E89BED6 (bit-reversed -> 0x6B7D9171)
 106:Src/BTLE.c    ****   // radio->setAddressWidth(4);
 107:Src/BTLE.c    ****   // radio->openReadingPipe(0,0x6B7D9171);
 108:Src/BTLE.c    ****   // radio->openWritingPipe(  0x6B7D9171);
 109:Src/BTLE.c    **** 
 110:Src/BTLE.c    ****   // radio->powerUp();
 111:Src/BTLE.c    **** 
 112:Src/BTLE.c    **** 
 113:Src/BTLE.c    ****   nRF24_CE_0();
 169              		.loc 1 113 0
 170 0008 FFF7FEFF 		bl	nRF24_CE_0
 171              	.LVL19:
 114:Src/BTLE.c    **** 
 115:Src/BTLE.c    ****   uint8_t writing_byte;
 116:Src/BTLE.c    **** 
 117:Src/BTLE.c    ****   writing_byte = 0x00;
 172              		.loc 1 117 0
 173 000c 0025     		movs	r5, #0
 174 000e 02AC     		add	r4, sp, #8
 175 0010 04F8015D 		strb	r5, [r4, #-1]!
 118:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + EN_AA, 1, &writing_byte);
 176              		.loc 1 118 0
 177 0014 2246     		mov	r2, r4
 178 0016 0121     		movs	r1, #1
 179 0018 2120     		movs	r0, #33
 180 001a FFF7FEFF 		bl	nRF24_verified_write_register
 181              	.LVL20:
 119:Src/BTLE.c    **** 
 120:Src/BTLE.c    ****   writing_byte = 0b00000110; // '00' - 1Mbps '11' - 0dBm
 182              		.loc 1 120 0
 183 001e 0626     		movs	r6, #6
 184 0020 8DF80760 		strb	r6, [sp, #7]
 121:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + RF_SETUP, 1, &writing_byte);
 185              		.loc 1 121 0
 186 0024 2246     		mov	r2, r4
 187 0026 0121     		movs	r1, #1
 188 0028 2620     		movs	r0, #38
 189 002a FFF7FEFF 		bl	nRF24_verified_write_register
 190              	.LVL21:
 122:Src/BTLE.c    **** 
 123:Src/BTLE.c    ****   writing_byte = frequency[current];
 191              		.loc 1 123 0
 192 002e 1B4B     		ldr	r3, .L19+4
 193 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 194 0032 1B4A     		ldr	r2, .L19+8
 195 0034 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 196 0036 8DF80730 		strb	r3, [sp, #7]
 124:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + RF_CH, 1, &writing_byte);
 197              		.loc 1 124 0
 198 003a 2246     		mov	r2, r4
 199 003c 0121     		movs	r1, #1
 200 003e 2520     		movs	r0, #37
 201 0040 FFF7FEFF 		bl	nRF24_verified_write_register
 202              	.LVL22:
 125:Src/BTLE.c    **** 
ARM GAS  /tmp/cckCRgnX.s 			page 7


 126:Src/BTLE.c    ****   writing_byte = 0b00000000; // Wait 250us, disable auto retransmit
 203              		.loc 1 126 0
 204 0044 8DF80750 		strb	r5, [sp, #7]
 127:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + SETUP_RETR, 1, &writing_byte);
 205              		.loc 1 127 0
 206 0048 2246     		mov	r2, r4
 207 004a 0121     		movs	r1, #1
 208 004c 2420     		movs	r0, #36
 209 004e FFF7FEFF 		bl	nRF24_verified_write_register
 210              	.LVL23:
 128:Src/BTLE.c    **** 
 129:Src/BTLE.c    ****   writing_byte = 0b00000010; // 4 bytes '10' on AW bits
 211              		.loc 1 129 0
 212 0052 0223     		movs	r3, #2
 213 0054 8DF80730 		strb	r3, [sp, #7]
 130:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + SETUP_AW, 1, &writing_byte);
 214              		.loc 1 130 0
 215 0058 2246     		mov	r2, r4
 216 005a 0121     		movs	r1, #1
 217 005c 2320     		movs	r0, #35
 218 005e FFF7FEFF 		bl	nRF24_verified_write_register
 219              	.LVL24:
 131:Src/BTLE.c    **** 
 132:Src/BTLE.c    ****   // Set TX_ADDR for sender. On the Receiver side, set RX_ADDR_P0 with same value.
 133:Src/BTLE.c    ****   uint8_t TX_ADDRESS[4] = {0x6B,0x7D,0x91,0x71};  // 4 byte transmit-address
 220              		.loc 1 133 0
 221 0062 104B     		ldr	r3, .L19+12
 222 0064 1B68     		ldr	r3, [r3]
 223 0066 02AD     		add	r5, sp, #8
 224 0068 45F8083D 		str	r3, [r5, #-8]!
 134:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + TX_ADDR, 4, TX_ADDRESS);     // Write transmit-ad
 225              		.loc 1 134 0
 226 006c 2A46     		mov	r2, r5
 227 006e 0421     		movs	r1, #4
 228 0070 3020     		movs	r0, #48
 229 0072 FFF7FEFF 		bl	nRF24_verified_write_register
 230              	.LVL25:
 135:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + RX_ADDR_P0, 4, TX_ADDRESS);     // Write transmit
 231              		.loc 1 135 0
 232 0076 2A46     		mov	r2, r5
 233 0078 0421     		movs	r1, #4
 234 007a 2A20     		movs	r0, #42
 235 007c FFF7FEFF 		bl	nRF24_verified_write_register
 236              	.LVL26:
 136:Src/BTLE.c    **** 
 137:Src/BTLE.c    ****   // PWR_UP, state transition to [Standby-I]
 138:Src/BTLE.c    ****   writing_byte = 0x06;
 237              		.loc 1 138 0
 238 0080 8DF80760 		strb	r6, [sp, #7]
 139:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + CONFIG, 1, &writing_byte);
 239              		.loc 1 139 0
 240 0084 2246     		mov	r2, r4
 241 0086 0121     		movs	r1, #1
 242 0088 2020     		movs	r0, #32
 243 008a FFF7FEFF 		bl	nRF24_verified_write_register
 244              	.LVL27:
 140:Src/BTLE.c    ****   spi_delay(150);
ARM GAS  /tmp/cckCRgnX.s 			page 8


 245              		.loc 1 140 0
 246 008e 9620     		movs	r0, #150
 247 0090 FFF7FEFF 		bl	spi_delay
 248              	.LVL28:
 141:Src/BTLE.c    **** 
 142:Src/BTLE.c    **** 
 143:Src/BTLE.c    ****   // CE is not set to 1, nRF24 still stays in [Standby-I] Mode.
 144:Src/BTLE.c    ****   // CE = 1 is not activated until we write to TX FIFO so stays in Standby-I mode.
 145:Src/BTLE.c    **** 
 146:Src/BTLE.c    **** 
 147:Src/BTLE.c    **** }
 249              		.loc 1 147 0
 250 0094 02B0     		add	sp, sp, #8
 251              	.LCFI4:
 252              		.cfi_def_cfa_offset 16
 253              		@ sp needed
 254 0096 70BD     		pop	{r4, r5, r6, pc}
 255              	.L20:
 256              		.align	2
 257              	.L19:
 258 0098 00000000 		.word	name
 259 009c 00000000 		.word	current
 260 00a0 00000000 		.word	.LANCHOR0
 261 00a4 00000000 		.word	.LANCHOR1
 262              		.cfi_endproc
 263              	.LFE133:
 265              		.section	.text.setChannel,"ax",%progbits
 266              		.align	1
 267              		.global	setChannel
 268              		.syntax unified
 269              		.thumb
 270              		.thumb_func
 271              		.fpu fpv4-sp-d16
 273              	setChannel:
 274              	.LFB134:
 148:Src/BTLE.c    **** 
 149:Src/BTLE.c    **** // set the current channel (from 37 to 39)
 150:Src/BTLE.c    **** void setChannel( uint8_t num ) {
 275              		.loc 1 150 0
 276              		.cfi_startproc
 277              		@ args = 0, pretend = 0, frame = 8
 278              		@ frame_needed = 0, uses_anonymous_args = 0
 279              	.LVL29:
 280 0000 00B5     		push	{lr}
 281              	.LCFI5:
 282              		.cfi_def_cfa_offset 4
 283              		.cfi_offset 14, -4
 284 0002 83B0     		sub	sp, sp, #12
 285              	.LCFI6:
 286              		.cfi_def_cfa_offset 16
 151:Src/BTLE.c    ****   current = min(2,max(0,num-37));
 287              		.loc 1 151 0
 288 0004 2538     		subs	r0, r0, #37
 289              	.LVL30:
 290 0006 0228     		cmp	r0, #2
 291 0008 10DC     		bgt	.L23
 292              		.loc 1 151 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/cckCRgnX.s 			page 9


 293 000a 20EAE070 		bic	r0, r0, r0, asr #31
 294 000e C0B2     		uxtb	r0, r0
 295              	.L22:
 296              		.loc 1 151 0 discriminator 4
 297 0010 074B     		ldr	r3, .L25
 298 0012 1870     		strb	r0, [r3]
 152:Src/BTLE.c    ****   // radio->setChannel( frequency[current] ); TODO
 153:Src/BTLE.c    ****   uint8_t writing_byte;
 154:Src/BTLE.c    ****   writing_byte = frequency[current];
 299              		.loc 1 154 0 is_stmt 1 discriminator 4
 300 0014 074B     		ldr	r3, .L25+4
 301 0016 1B5C     		ldrb	r3, [r3, r0]	@ zero_extendqisi2
 302 0018 02AA     		add	r2, sp, #8
 303 001a 02F8013D 		strb	r3, [r2, #-1]!
 155:Src/BTLE.c    ****   spi_write_register(W_REGISTER_MASK + RF_CH, 1, &writing_byte);
 304              		.loc 1 155 0 discriminator 4
 305 001e 0121     		movs	r1, #1
 306 0020 2520     		movs	r0, #37
 307 0022 FFF7FEFF 		bl	spi_write_register
 308              	.LVL31:
 156:Src/BTLE.c    **** }
 309              		.loc 1 156 0 discriminator 4
 310 0026 03B0     		add	sp, sp, #12
 311              	.LCFI7:
 312              		.cfi_remember_state
 313              		.cfi_def_cfa_offset 4
 314              		@ sp needed
 315 0028 5DF804FB 		ldr	pc, [sp], #4
 316              	.L23:
 317              	.LCFI8:
 318              		.cfi_restore_state
 151:Src/BTLE.c    ****   // radio->setChannel( frequency[current] ); TODO
 319              		.loc 1 151 0
 320 002c 0220     		movs	r0, #2
 321 002e EFE7     		b	.L22
 322              	.L26:
 323              		.align	2
 324              	.L25:
 325 0030 00000000 		.word	current
 326 0034 00000000 		.word	.LANCHOR0
 327              		.cfi_endproc
 328              	.LFE134:
 330              		.section	.text.hopChannel,"ax",%progbits
 331              		.align	1
 332              		.global	hopChannel
 333              		.syntax unified
 334              		.thumb
 335              		.thumb_func
 336              		.fpu fpv4-sp-d16
 338              	hopChannel:
 339              	.LFB135:
 157:Src/BTLE.c    **** 
 158:Src/BTLE.c    **** // hop to the next channel
 159:Src/BTLE.c    **** void hopChannel() {
 340              		.loc 1 159 0
 341              		.cfi_startproc
 342              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/cckCRgnX.s 			page 10


 343              		@ frame_needed = 0, uses_anonymous_args = 0
 344 0000 00B5     		push	{lr}
 345              	.LCFI9:
 346              		.cfi_def_cfa_offset 4
 347              		.cfi_offset 14, -4
 348 0002 83B0     		sub	sp, sp, #12
 349              	.LCFI10:
 350              		.cfi_def_cfa_offset 16
 160:Src/BTLE.c    ****   current++;
 351              		.loc 1 160 0
 352 0004 0B4A     		ldr	r2, .L30
 353 0006 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 354 0008 0133     		adds	r3, r3, #1
 355 000a DBB2     		uxtb	r3, r3
 356 000c 1370     		strb	r3, [r2]
 161:Src/BTLE.c    ****   if (current >= sizeof(channel)) current = 0;
 357              		.loc 1 161 0
 358 000e 022B     		cmp	r3, #2
 359 0010 02D9     		bls	.L28
 360              		.loc 1 161 0 is_stmt 0 discriminator 1
 361 0012 0022     		movs	r2, #0
 362 0014 074B     		ldr	r3, .L30
 363 0016 1A70     		strb	r2, [r3]
 364              	.L28:
 162:Src/BTLE.c    ****   // radio->setChannel( frequency[current] ); TODO
 163:Src/BTLE.c    ****   uint8_t writing_byte;
 164:Src/BTLE.c    ****   writing_byte = frequency[current];
 365              		.loc 1 164 0 is_stmt 1
 366 0018 064B     		ldr	r3, .L30
 367 001a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 368 001c 064A     		ldr	r2, .L30+4
 369 001e D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 370 0020 02AA     		add	r2, sp, #8
 371 0022 02F8013D 		strb	r3, [r2, #-1]!
 165:Src/BTLE.c    ****   spi_write_register(W_REGISTER_MASK + RF_CH, 1, &writing_byte);
 372              		.loc 1 165 0
 373 0026 0121     		movs	r1, #1
 374 0028 2520     		movs	r0, #37
 375 002a FFF7FEFF 		bl	spi_write_register
 376              	.LVL32:
 166:Src/BTLE.c    **** }
 377              		.loc 1 166 0
 378 002e 03B0     		add	sp, sp, #12
 379              	.LCFI11:
 380              		.cfi_def_cfa_offset 4
 381              		@ sp needed
 382 0030 5DF804FB 		ldr	pc, [sp], #4
 383              	.L31:
 384              		.align	2
 385              	.L30:
 386 0034 00000000 		.word	current
 387 0038 00000000 		.word	.LANCHOR0
 388              		.cfi_endproc
 389              	.LFE135:
 391              		.section	.text.addChunk,"ax",%progbits
 392              		.align	1
 393              		.global	addChunk
ARM GAS  /tmp/cckCRgnX.s 			page 11


 394              		.syntax unified
 395              		.thumb
 396              		.thumb_func
 397              		.fpu fpv4-sp-d16
 399              	addChunk:
 400              	.LFB138:
 167:Src/BTLE.c    **** 
 168:Src/BTLE.c    **** 
 169:Src/BTLE.c    **** // Broadcast an advertisement packet with optional payload
 170:Src/BTLE.c    **** // Data type will be 0xFF (Manufacturer Specific Data)
 171:Src/BTLE.c    **** bool advertise_short( void* buf, uint8_t buflen ) {
 172:Src/BTLE.c    ****   return advertise(0xFF, buf, buflen);
 173:Src/BTLE.c    **** }
 174:Src/BTLE.c    **** 
 175:Src/BTLE.c    **** 
 176:Src/BTLE.c    **** /** @brief Broadcast an advertisement packet with a specific data type
 177:Src/BTLE.c    ****  *  @note  Standardized data types can be seen here: 
 178:Src/BTLE.c    ****  *  https://www.bluetooth.org/en-us/specification/assigned-numbers/generic-access-profile
 179:Src/BTLE.c    ****  *
 180:Src/BTLE.c    **** bool advertise( uint8_t data_type, void* buf, uint8_t buflen ) {
 181:Src/BTLE.c    ****   preparePacket();
 182:Src/BTLE.c    **** 
 183:Src/BTLE.c    **** 	char msg[64];
 184:Src/BTLE.c    ****   // add custom data, if applicable
 185:Src/BTLE.c    ****   if (buflen > 0) {
 186:Src/BTLE.c    ****     bool success = addChunk(data_type, buflen, buf);
 187:Src/BTLE.c    **** 		sprintf(msg, "advertise <success> variable returns: %s\n", success ? "true" : "false");
 188:Src/BTLE.c    **** 		serial_print(msg);
 189:Src/BTLE.c    ****     if (!success) {
 190:Src/BTLE.c    ****       return false;
 191:Src/BTLE.c    ****     }
 192:Src/BTLE.c    ****   }
 193:Src/BTLE.c    **** 
 194:Src/BTLE.c    ****   transmitPacket();
 195:Src/BTLE.c    ****   return true;
 196:Src/BTLE.c    **** }
 197:Src/BTLE.c    **** */
 198:Src/BTLE.c    **** 
 199:Src/BTLE.c    **** 
 200:Src/BTLE.c    **** bool advertise( uint8_t data_type, void* buf, uint8_t buflen ) {
 201:Src/BTLE.c    **** 	// name & total payload size
 202:Src/BTLE.c    **** 	uint8_t namelen = strlen(name);
 203:Src/BTLE.c    **** 	uint8_t pls = 0;
 204:Src/BTLE.c    **** 
 205:Src/BTLE.c    **** 	// insert pseudo-random MAC address
 206:Src/BTLE.c    **** 	buffer.mac[0] = ((__TIME__[6]-0x30) << 4) | (__TIME__[7]-0x30);
 207:Src/BTLE.c    **** 	buffer.mac[1] = ((__TIME__[3]-0x30) << 4) | (__TIME__[4]-0x30);
 208:Src/BTLE.c    **** 	buffer.mac[2] = ((__TIME__[0]-0x30) << 4) | (__TIME__[1]-0x30);
 209:Src/BTLE.c    **** 	buffer.mac[3] = ((__DATE__[4]-0x30) << 4) | (__DATE__[5]-0x30);
 210:Src/BTLE.c    **** 	buffer.mac[4] = month(__DATE__);
 211:Src/BTLE.c    **** 	buffer.mac[5] = ((__DATE__[9]-0x30) << 4) | (__DATE__[10]-0x30) | 0xC0; // static random address s
 212:Src/BTLE.c    **** 
 213:Src/BTLE.c    **** 	// add device descriptor chunk
 214:Src/BTLE.c    **** 	chunk(buffer,pls)->size = 0x02;  // chunk size: 2
 215:Src/BTLE.c    **** 	chunk(buffer,pls)->type = 0x01;  // chunk type: device flags
 216:Src/BTLE.c    **** 	chunk(buffer,pls)->data[0]= 0x05;  // flags: LE-only, limited discovery mode
 217:Src/BTLE.c    **** 	pls += 3;
ARM GAS  /tmp/cckCRgnX.s 			page 12


 218:Src/BTLE.c    **** 
 219:Src/BTLE.c    **** 	// add "complete name" chunk
 220:Src/BTLE.c    **** 	chunk(buffer,pls)->size = namelen+1;  // chunk size
 221:Src/BTLE.c    **** 	chunk(buffer,pls)->type = 0x09;       // chunk type
 222:Src/BTLE.c    **** 	for (uint8_t i = 0; i < namelen; i++)
 223:Src/BTLE.c    **** 		chunk(buffer,pls)->data[i] = name[i];
 224:Src/BTLE.c    **** 	pls += namelen+2;
 225:Src/BTLE.c    **** 
 226:Src/BTLE.c    **** 	// add custom data, if applicable
 227:Src/BTLE.c    **** 	if (buflen > 0) {
 228:Src/BTLE.c    **** 		chunk(buffer,pls)->size = buflen+1;  // chunk size
 229:Src/BTLE.c    **** 		chunk(buffer,pls)->type = data_type; // chunk type
 230:Src/BTLE.c    **** 		for (uint8_t i = 0; i < buflen; i++)
 231:Src/BTLE.c    **** 			chunk(buffer,pls)->data[i] = ((uint8_t*)buf)[i];
 232:Src/BTLE.c    **** 		pls += buflen+2;
 233:Src/BTLE.c    **** 	}
 234:Src/BTLE.c    **** 
 235:Src/BTLE.c    **** 	// total payload size must be 21 bytes or less
 236:Src/BTLE.c    **** 	if (pls > 21)
 237:Src/BTLE.c    **** 		return false;
 238:Src/BTLE.c    **** 
 239:Src/BTLE.c    **** 	// assemble header
 240:Src/BTLE.c    **** 	buffer.pdu_type = 0x42;    // PDU type: ADV_NONCONN_IND, TX address is random
 241:Src/BTLE.c    **** 	buffer.pl_size = pls+6;    // set final payload size in header incl. MAC
 242:Src/BTLE.c    **** 
 243:Src/BTLE.c    **** 	// calculate CRC over header+MAC+payload, append after payload
 244:Src/BTLE.c    **** 	uint8_t* outbuf = (uint8_t*)&buffer;
 245:Src/BTLE.c    **** 	crc( pls+8, outbuf+pls+8);
 246:Src/BTLE.c    **** 
 247:Src/BTLE.c    **** 	// whiten header+MAC+payload+CRC, swap bit order
 248:Src/BTLE.c    **** 	whiten( pls+11 );
 249:Src/BTLE.c    **** 	swapbuf( pls+11 );
 250:Src/BTLE.c    **** 
 251:Src/BTLE.c    **** 	// flush buffers and send
 252:Src/BTLE.c    **** 	// radio->stopListening();
 253:Src/BTLE.c    **** 	// radio->write( outbuf, pls+11 );
 254:Src/BTLE.c    **** 
 255:Src/BTLE.c    ****   uint8_t writing_byte;
 256:Src/BTLE.c    ****   writing_byte = 0b00000010; // PWR_UP = 1 PRIM_RX = 0 -> TX mode!
 257:Src/BTLE.c    ****   spi_write_register(W_REGISTER_MASK + CONFIG, 1, &writing_byte);
 258:Src/BTLE.c    **** 
 259:Src/BTLE.c    ****   spi_write_register(W_TX_PAYLOAD, pls+11, outbuf);
 260:Src/BTLE.c    ****   nRF24_CE_1(); // fire out the packet
 261:Src/BTLE.c    **** 
 262:Src/BTLE.c    **** 	return true;
 263:Src/BTLE.c    **** }
 264:Src/BTLE.c    **** 
 265:Src/BTLE.c    **** 
 266:Src/BTLE.c    **** 
 267:Src/BTLE.c    **** bool addChunk(uint8_t chunk_type, uint8_t buflen, const void* buf) {
 401              		.loc 1 267 0
 402              		.cfi_startproc
 403              		@ args = 0, pretend = 0, frame = 0
 404              		@ frame_needed = 0, uses_anonymous_args = 0
 405              		@ link register save eliminated.
 406              	.LVL33:
 407 0000 F0B4     		push	{r4, r5, r6, r7}
ARM GAS  /tmp/cckCRgnX.s 			page 13


 408              	.LCFI12:
 409              		.cfi_def_cfa_offset 16
 410              		.cfi_offset 4, -16
 411              		.cfi_offset 5, -12
 412              		.cfi_offset 6, -8
 413              		.cfi_offset 7, -4
 268:Src/BTLE.c    ****   if (buffer.pl_size + buflen + 2 > 21 + 6) // (buflen+2) is how much this chunk will take, 21 is p
 414              		.loc 1 268 0
 415 0002 0F4B     		ldr	r3, .L38
 416 0004 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 417 0006 CC18     		adds	r4, r1, r3
 418 0008 0234     		adds	r4, r4, #2
 419 000a 1B2C     		cmp	r4, #27
 420 000c 16DC     		bgt	.L36
 269:Src/BTLE.c    ****     return false;
 270:Src/BTLE.c    ****   struct btle_pdu_chunk* chunk = (struct btle_pdu_chunk*) (buffer.payload+buffer.pl_size-6);
 421              		.loc 1 270 0
 422 000e 9E1F     		subs	r6, r3, #6
 423 0010 0C4F     		ldr	r7, .L38+4
 424 0012 F519     		adds	r5, r6, r7
 425              	.LVL34:
 271:Src/BTLE.c    ****   chunk->type = chunk_type;
 426              		.loc 1 271 0
 427 0014 6870     		strb	r0, [r5, #1]
 428              	.LVL35:
 429              	.LBB4:
 272:Src/BTLE.c    ****   for (uint8_t i = 0; i < buflen; i++)
 430              		.loc 1 272 0
 431 0016 0023     		movs	r3, #0
 432 0018 04E0     		b	.L34
 433              	.LVL36:
 434              	.L35:
 273:Src/BTLE.c    ****     chunk->data[i] = ((uint8_t*)buf)[i];
 435              		.loc 1 273 0 discriminator 3
 436 001a D45C     		ldrb	r4, [r2, r3]	@ zero_extendqisi2
 437 001c E818     		adds	r0, r5, r3
 438 001e 8470     		strb	r4, [r0, #2]
 272:Src/BTLE.c    ****   for (uint8_t i = 0; i < buflen; i++)
 439              		.loc 1 272 0 discriminator 3
 440 0020 0133     		adds	r3, r3, #1
 441              	.LVL37:
 442 0022 DBB2     		uxtb	r3, r3
 443              	.LVL38:
 444              	.L34:
 272:Src/BTLE.c    ****   for (uint8_t i = 0; i < buflen; i++)
 445              		.loc 1 272 0 is_stmt 0 discriminator 1
 446 0024 8B42     		cmp	r3, r1
 447 0026 F8D3     		bcc	.L35
 448              	.LBE4:
 274:Src/BTLE.c    ****   chunk->size = buflen + 1;
 449              		.loc 1 274 0 is_stmt 1
 450 0028 4B1C     		adds	r3, r1, #1
 451              	.LVL39:
 452 002a BB55     		strb	r3, [r7, r6]
 275:Src/BTLE.c    ****   buffer.pl_size += buflen + 2;
 453              		.loc 1 275 0
 454 002c 044B     		ldr	r3, .L38
ARM GAS  /tmp/cckCRgnX.s 			page 14


 455 002e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 456              	.LVL40:
 457 0030 1144     		add	r1, r1, r2
 458              	.LVL41:
 459 0032 0231     		adds	r1, r1, #2
 460 0034 5970     		strb	r1, [r3, #1]
 276:Src/BTLE.c    ****   return true;
 461              		.loc 1 276 0
 462 0036 0120     		movs	r0, #1
 463              	.LVL42:
 464              	.L33:
 277:Src/BTLE.c    **** }
 465              		.loc 1 277 0
 466 0038 F0BC     		pop	{r4, r5, r6, r7}
 467              	.LCFI13:
 468              		.cfi_remember_state
 469              		.cfi_restore 7
 470              		.cfi_restore 6
 471              		.cfi_restore 5
 472              		.cfi_restore 4
 473              		.cfi_def_cfa_offset 0
 474 003a 7047     		bx	lr
 475              	.LVL43:
 476              	.L36:
 477              	.LCFI14:
 478              		.cfi_restore_state
 269:Src/BTLE.c    ****   struct btle_pdu_chunk* chunk = (struct btle_pdu_chunk*) (buffer.payload+buffer.pl_size-6);
 479              		.loc 1 269 0
 480 003c 0020     		movs	r0, #0
 481              	.LVL44:
 482 003e FBE7     		b	.L33
 483              	.L39:
 484              		.align	2
 485              	.L38:
 486 0040 00000000 		.word	buffer
 487 0044 08000000 		.word	buffer+8
 488              		.cfi_endproc
 489              	.LFE138:
 491              		.section	.text.preparePacket,"ax",%progbits
 492              		.align	1
 493              		.global	preparePacket
 494              		.syntax unified
 495              		.thumb
 496              		.thumb_func
 497              		.fpu fpv4-sp-d16
 499              	preparePacket:
 500              	.LFB139:
 278:Src/BTLE.c    **** 
 279:Src/BTLE.c    **** 
 280:Src/BTLE.c    **** 
 281:Src/BTLE.c    **** 
 282:Src/BTLE.c    **** 
 283:Src/BTLE.c    **** void preparePacket() {
 501              		.loc 1 283 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 8
 504              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cckCRgnX.s 			page 15


 505 0000 10B5     		push	{r4, lr}
 506              	.LCFI15:
 507              		.cfi_def_cfa_offset 8
 508              		.cfi_offset 4, -8
 509              		.cfi_offset 14, -4
 510 0002 82B0     		sub	sp, sp, #8
 511              	.LCFI16:
 512              		.cfi_def_cfa_offset 16
 284:Src/BTLE.c    ****   // insert pseudo-random MAC address
 285:Src/BTLE.c    ****   buffer.mac[0] = ((__TIME__[6]-0x30) << 4) | (__TIME__[7]-0x30);
 513              		.loc 1 285 0
 514 0004 134B     		ldr	r3, .L44
 515 0006 1122     		movs	r2, #17
 516 0008 9A70     		strb	r2, [r3, #2]
 286:Src/BTLE.c    ****   buffer.mac[1] = ((__TIME__[3]-0x30) << 4) | (__TIME__[4]-0x30);
 517              		.loc 1 286 0
 518 000a 5422     		movs	r2, #84
 519 000c DA70     		strb	r2, [r3, #3]
 287:Src/BTLE.c    ****   buffer.mac[2] = ((__TIME__[0]-0x30) << 4) | (__TIME__[1]-0x30);
 520              		.loc 1 287 0
 521 000e 1722     		movs	r2, #23
 522 0010 1A71     		strb	r2, [r3, #4]
 288:Src/BTLE.c    ****   buffer.mac[3] = ((__DATE__[4]-0x30) << 4) | (__DATE__[5]-0x30);
 523              		.loc 1 288 0
 524 0012 2322     		movs	r2, #35
 525 0014 5A71     		strb	r2, [r3, #5]
 289:Src/BTLE.c    ****   buffer.mac[4] = month(__DATE__);
 526              		.loc 1 289 0
 527 0016 0422     		movs	r2, #4
 528 0018 9A71     		strb	r2, [r3, #6]
 290:Src/BTLE.c    ****   buffer.mac[5] = ((__DATE__[9]-0x30) << 4) | (__DATE__[10]-0x30) | 0xC0; // static random address 
 529              		.loc 1 290 0
 530 001a E222     		movs	r2, #226
 531 001c DA71     		strb	r2, [r3, #7]
 291:Src/BTLE.c    ****   
 292:Src/BTLE.c    ****   buffer.pdu_type = 0x42;    // PDU type: ADV_NONCONN_IND, TX address is random
 532              		.loc 1 292 0
 533 001e 4222     		movs	r2, #66
 534 0020 1A70     		strb	r2, [r3]
 293:Src/BTLE.c    ****   buffer.pl_size = 6; //including MAC
 535              		.loc 1 293 0
 536 0022 0622     		movs	r2, #6
 537 0024 5A70     		strb	r2, [r3, #1]
 294:Src/BTLE.c    ****   
 295:Src/BTLE.c    ****   // add device descriptor chunk
 296:Src/BTLE.c    ****   uint8_t flags = 0x05;
 538              		.loc 1 296 0
 539 0026 02AA     		add	r2, sp, #8
 540 0028 0523     		movs	r3, #5
 541 002a 02F8013D 		strb	r3, [r2, #-1]!
 297:Src/BTLE.c    ****   addChunk(0x01, 1, &flags);
 542              		.loc 1 297 0
 543 002e 0121     		movs	r1, #1
 544 0030 0846     		mov	r0, r1
 545 0032 FFF7FEFF 		bl	addChunk
 546              	.LVL45:
 298:Src/BTLE.c    ****   
ARM GAS  /tmp/cckCRgnX.s 			page 16


 299:Src/BTLE.c    ****   // add "complete name" chunk
 300:Src/BTLE.c    ****   if (strlen(name) > 0) {
 547              		.loc 1 300 0
 548 0036 084B     		ldr	r3, .L44+4
 549 0038 1C68     		ldr	r4, [r3]
 550 003a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 551 003c 0BB9     		cbnz	r3, .L43
 552              	.L40:
 301:Src/BTLE.c    ****     addChunk(0x09, strlen(name), name);
 302:Src/BTLE.c    ****   }
 303:Src/BTLE.c    **** }
 553              		.loc 1 303 0
 554 003e 02B0     		add	sp, sp, #8
 555              	.LCFI17:
 556              		.cfi_remember_state
 557              		.cfi_def_cfa_offset 8
 558              		@ sp needed
 559 0040 10BD     		pop	{r4, pc}
 560              	.L43:
 561              	.LCFI18:
 562              		.cfi_restore_state
 301:Src/BTLE.c    ****     addChunk(0x09, strlen(name), name);
 563              		.loc 1 301 0
 564 0042 2046     		mov	r0, r4
 565 0044 FFF7FEFF 		bl	strlen
 566              	.LVL46:
 567 0048 2246     		mov	r2, r4
 568 004a C1B2     		uxtb	r1, r0
 569 004c 0920     		movs	r0, #9
 570 004e FFF7FEFF 		bl	addChunk
 571              	.LVL47:
 572              		.loc 1 303 0
 573 0052 F4E7     		b	.L40
 574              	.L45:
 575              		.align	2
 576              	.L44:
 577 0054 00000000 		.word	buffer
 578 0058 00000000 		.word	name
 579              		.cfi_endproc
 580              	.LFE139:
 582              		.section	.text.whiten,"ax",%progbits
 583              		.align	1
 584              		.global	whiten
 585              		.syntax unified
 586              		.thumb
 587              		.thumb_func
 588              		.fpu fpv4-sp-d16
 590              	whiten:
 591              	.LFB141:
 304:Src/BTLE.c    **** 
 305:Src/BTLE.c    **** 
 306:Src/BTLE.c    **** void transmitPacket() {
 307:Src/BTLE.c    ****   uint8_t pls = buffer.pl_size - 6;
 308:Src/BTLE.c    ****   // calculate CRC over header+MAC+payload, append after payload
 309:Src/BTLE.c    ****   uint8_t* outbuf = (uint8_t*)&buffer;
 310:Src/BTLE.c    ****   crc( pls+8, outbuf+pls+8);
 311:Src/BTLE.c    ****   
ARM GAS  /tmp/cckCRgnX.s 			page 17


 312:Src/BTLE.c    ****   // whiten header+MAC+payload+CRC, swap bit order
 313:Src/BTLE.c    ****   whiten( pls+11 );
 314:Src/BTLE.c    ****   swapbuf( pls+11 );
 315:Src/BTLE.c    ****   // flush buffers and send
 316:Src/BTLE.c    ****   // radio->stopListening(); TODO
 317:Src/BTLE.c    ****   // radio->write( outbuf, pls+11 ); TODO
 318:Src/BTLE.c    **** 
 319:Src/BTLE.c    **** 
 320:Src/BTLE.c    **** 	char msg[64];
 321:Src/BTLE.c    **** 	serial_print("printing outbuf: ");
 322:Src/BTLE.c    **** 	for (int i = 0; i < pls+11; ++i) {
 323:Src/BTLE.c    **** 		sprintf(msg, "%#02x", outbuf[i]);
 324:Src/BTLE.c    **** 		serial_print(msg);
 325:Src/BTLE.c    **** 	}
 326:Src/BTLE.c    **** 
 327:Src/BTLE.c    **** 	serial_print(msg);
 328:Src/BTLE.c    **** 
 329:Src/BTLE.c    ****   uint8_t writing_byte;
 330:Src/BTLE.c    ****   writing_byte = 0b00000010; // PWR_UP = 1 PRIM_RX = 0 -> TX mode!
 331:Src/BTLE.c    ****   spi_write_register(W_REGISTER_MASK + CONFIG, 1, &writing_byte);
 332:Src/BTLE.c    **** 
 333:Src/BTLE.c    ****   spi_write_register(W_TX_PAYLOAD, pls+11, outbuf);
 334:Src/BTLE.c    ****   nRF24_CE_1(); // fire out the packet
 335:Src/BTLE.c    **** }
 336:Src/BTLE.c    **** 
 337:Src/BTLE.c    **** 
 338:Src/BTLE.c    **** /*
 339:Src/BTLE.c    **** // listen for advertisement packets
 340:Src/BTLE.c    **** bool listen(int timeout) {
 341:Src/BTLE.c    ****   if (timeout == 0) 
 342:Src/BTLE.c    ****   {
 343:Src/BTLE.c    ****     timeout = 100;
 344:Src/BTLE.c    ****   }
 345:Src/BTLE.c    **** 
 346:Src/BTLE.c    ****   // radio->startListening(); TODO
 347:Src/BTLE.c    ****   uint8_t writing_byte;
 348:Src/BTLE.c    ****   writing_byte = 0b00000011; // PWR_UP = 1 PRIM_RX = 1 -> RX mode!
 349:Src/BTLE.c    ****   nRF24_verified_write_register(W_REGISTER_MASK + CONFIG, 1, &writing_byte);
 350:Src/BTLE.c    **** 
 351:Src/BTLE.c    ****   nRF24_CE_1(); // Enters RX mode
 352:Src/BTLE.c    ****   
 353:Src/BTLE.c    ****   HAL_Delay(timeout); //delay(timeout);
 354:Src/BTLE.c    **** 
 355:Src/BTLE.c    ****   // if (!radio->available())
 356:Src/BTLE.c    ****   //     return false; TODO
 357:Src/BTLE.c    **** 
 358:Src/BTLE.c    ****   uint8_t total_size = 0;
 359:Src/BTLE.c    ****   uint8_t* inbuf = (uint8_t*)&buffer;
 360:Src/BTLE.c    **** 
 361:Src/BTLE.c    ****   // while (radio->available()) { // TODO
 362:Src/BTLE.c    ****     while(1) 
 363:Src/BTLE.c    ****     {
 364:Src/BTLE.c    **** 
 365:Src/BTLE.c    ****     // fetch the payload, and check if there are more left
 366:Src/BTLE.c    ****     // radio->read( inbuf, sizeof(buffer) ); // TODO
 367:Src/BTLE.c    **** 
 368:Src/BTLE.c    ****     uint8_t nRF24_status = nRF24_get_STATUS();
ARM GAS  /tmp/cckCRgnX.s 			page 18


 369:Src/BTLE.c    **** 
 370:Src/BTLE.c    ****     if (nRF24_status & 0x40){
 371:Src/BTLE.c    ****       nRF24_CE_0(); // stop receiving
 372:Src/BTLE.c    ****       spi_read_register(R_RX_PAYLOAD, sizeof(buffer), inbuf); // read received payload
 373:Src/BTLE.c    ****     }
 374:Src/BTLE.c    ****     spi_write_register(W_REGISTER_MASK + STATUS, 1, &nRF24_status); // clear status
 375:Src/BTLE.c    ****     nRF24_CE_1();
 376:Src/BTLE.c    **** 
 377:Src/BTLE.c    **** 
 378:Src/BTLE.c    ****     // decode: swap bit order, un-whiten
 379:Src/BTLE.c    ****     swapbuf( sizeof(buffer) );
 380:Src/BTLE.c    ****     whiten( sizeof(buffer) );
 381:Src/BTLE.c    ****     
 382:Src/BTLE.c    ****     // size is w/o header+CRC -> add 2 bytes header
 383:Src/BTLE.c    ****     total_size = inbuf[1]+2;
 384:Src/BTLE.c    ****     uint8_t in_crc[3];
 385:Src/BTLE.c    **** 
 386:Src/BTLE.c    ****     // calculate & compare CRC
 387:Src/BTLE.c    ****     crc( total_size, in_crc );
 388:Src/BTLE.c    ****     for (uint8_t i = 0; i < 3; i++)
 389:Src/BTLE.c    ****       if (inbuf[total_size+i] != in_crc[i])
 390:Src/BTLE.c    ****         return false;
 391:Src/BTLE.c    ****   // }
 392:Src/BTLE.c    ****     }
 393:Src/BTLE.c    **** 
 394:Src/BTLE.c    ****   return true;
 395:Src/BTLE.c    **** }
 396:Src/BTLE.c    **** */
 397:Src/BTLE.c    **** 
 398:Src/BTLE.c    **** 
 399:Src/BTLE.c    **** // see BT Core Spec 4.0, Section 6.B.3.2
 400:Src/BTLE.c    **** void whiten( uint8_t len ) {
 592              		.loc 1 400 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 0
 595              		@ frame_needed = 0, uses_anonymous_args = 0
 596              		@ link register save eliminated.
 597              	.LVL48:
 598 0000 30B4     		push	{r4, r5}
 599              	.LCFI19:
 600              		.cfi_def_cfa_offset 8
 601              		.cfi_offset 4, -8
 602              		.cfi_offset 5, -4
 603              	.LVL49:
 401:Src/BTLE.c    **** 
 402:Src/BTLE.c    ****   uint8_t* buf = (uint8_t*)&buffer;
 403:Src/BTLE.c    **** 
 404:Src/BTLE.c    ****   // initialize LFSR with current channel, set bit 6
 405:Src/BTLE.c    ****   uint8_t lfsr = channel[current] | 0x40;
 604              		.loc 1 405 0
 605 0002 104B     		ldr	r3, .L55
 606 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 607 0006 104A     		ldr	r2, .L55+4
 608 0008 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 609 000a 42F04002 		orr	r2, r2, #64
 610              	.LVL50:
 402:Src/BTLE.c    **** 
ARM GAS  /tmp/cckCRgnX.s 			page 19


 611              		.loc 1 402 0
 612 000e 0F4D     		ldr	r5, .L55+8
 406:Src/BTLE.c    **** 
 407:Src/BTLE.c    ****   while (len--) {
 613              		.loc 1 407 0
 614 0010 0FE0     		b	.L47
 615              	.LVL51:
 616              	.L48:
 617              	.LBB5:
 618              	.LBB6:
 408:Src/BTLE.c    ****     uint8_t res = 0;
 409:Src/BTLE.c    ****     // LFSR in "wire bit order"
 410:Src/BTLE.c    ****     for (uint8_t i = 1; i; i <<= 1) {
 411:Src/BTLE.c    ****       if (lfsr & 0x01) {
 412:Src/BTLE.c    ****         lfsr ^= 0x88;
 413:Src/BTLE.c    ****         res |= i;
 414:Src/BTLE.c    ****       }
 415:Src/BTLE.c    ****       lfsr >>= 1;
 619              		.loc 1 415 0 discriminator 2
 620 0012 5208     		lsrs	r2, r2, #1
 621              	.LVL52:
 410:Src/BTLE.c    ****       if (lfsr & 0x01) {
 622              		.loc 1 410 0 discriminator 2
 623 0014 5B00     		lsls	r3, r3, #1
 624              	.LVL53:
 625 0016 DBB2     		uxtb	r3, r3
 626              	.LVL54:
 627              	.L50:
 410:Src/BTLE.c    ****       if (lfsr & 0x01) {
 628              		.loc 1 410 0 is_stmt 0 discriminator 1
 629 0018 33B1     		cbz	r3, .L53
 411:Src/BTLE.c    ****         lfsr ^= 0x88;
 630              		.loc 1 411 0 is_stmt 1
 631 001a 12F0010F 		tst	r2, #1
 632 001e F8D0     		beq	.L48
 412:Src/BTLE.c    ****         res |= i;
 633              		.loc 1 412 0
 634 0020 82F08802 		eor	r2, r2, #136
 635              	.LVL55:
 413:Src/BTLE.c    ****       }
 636              		.loc 1 413 0
 637 0024 1943     		orrs	r1, r1, r3
 638              	.LVL56:
 639 0026 F4E7     		b	.L48
 640              	.L53:
 641              	.LVL57:
 642              	.LBE6:
 416:Src/BTLE.c    ****     }
 417:Src/BTLE.c    ****     *(buf++) ^= res;
 643              		.loc 1 417 0
 644 0028 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 645              	.LVL58:
 646 002a 5940     		eors	r1, r1, r3
 647              	.LVL59:
 648 002c 2970     		strb	r1, [r5]
 649 002e 0135     		adds	r5, r5, #1
 650              	.LVL60:
ARM GAS  /tmp/cckCRgnX.s 			page 20


 651              	.LBE5:
 407:Src/BTLE.c    ****     uint8_t res = 0;
 652              		.loc 1 407 0
 653 0030 2046     		mov	r0, r4
 654              	.LVL61:
 655              	.L47:
 656 0032 431E     		subs	r3, r0, #1
 657 0034 DCB2     		uxtb	r4, r3
 658              	.LVL62:
 659 0036 10B1     		cbz	r0, .L54
 660 0038 0123     		movs	r3, #1
 661 003a 0021     		movs	r1, #0
 662 003c ECE7     		b	.L50
 663              	.L54:
 418:Src/BTLE.c    ****   }
 419:Src/BTLE.c    **** }
 664              		.loc 1 419 0
 665 003e 30BC     		pop	{r4, r5}
 666              	.LCFI20:
 667              		.cfi_restore 5
 668              		.cfi_restore 4
 669              		.cfi_def_cfa_offset 0
 670              	.LVL63:
 671 0040 7047     		bx	lr
 672              	.L56:
 673 0042 00BF     		.align	2
 674              	.L55:
 675 0044 00000000 		.word	current
 676 0048 00000000 		.word	.LANCHOR2
 677 004c 00000000 		.word	buffer
 678              		.cfi_endproc
 679              	.LFE141:
 681              		.section	.text.crc,"ax",%progbits
 682              		.align	1
 683              		.global	crc
 684              		.syntax unified
 685              		.thumb
 686              		.thumb_func
 687              		.fpu fpv4-sp-d16
 689              	crc:
 690              	.LFB142:
 420:Src/BTLE.c    **** 
 421:Src/BTLE.c    **** // see BT Core Spec 4.0, Section 6.B.3.1.1
 422:Src/BTLE.c    **** void crc( uint8_t len, uint8_t* dst ) {
 691              		.loc 1 422 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 0
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              		@ link register save eliminated.
 696              	.LVL64:
 697 0000 F0B4     		push	{r4, r5, r6, r7}
 698              	.LCFI21:
 699              		.cfi_def_cfa_offset 16
 700              		.cfi_offset 4, -16
 701              		.cfi_offset 5, -12
 702              		.cfi_offset 6, -8
 703              		.cfi_offset 7, -4
ARM GAS  /tmp/cckCRgnX.s 			page 21


 704              	.LVL65:
 423:Src/BTLE.c    **** 
 424:Src/BTLE.c    ****   uint8_t* buf = (uint8_t*)&buffer;
 425:Src/BTLE.c    **** 
 426:Src/BTLE.c    ****   // initialize 24-bit shift register in "wire bit order"
 427:Src/BTLE.c    ****   // dst[0] = bits 23-16, dst[1] = bits 15-8, dst[2] = bits 7-0
 428:Src/BTLE.c    ****   dst[0] = 0xAA;
 705              		.loc 1 428 0
 706 0002 AA23     		movs	r3, #170
 707 0004 0B70     		strb	r3, [r1]
 429:Src/BTLE.c    ****   dst[1] = 0xAA;
 708              		.loc 1 429 0
 709 0006 4B70     		strb	r3, [r1, #1]
 430:Src/BTLE.c    ****   dst[2] = 0xAA;
 710              		.loc 1 430 0
 711 0008 8B70     		strb	r3, [r1, #2]
 424:Src/BTLE.c    **** 
 712              		.loc 1 424 0
 713 000a 1A4B     		ldr	r3, .L68
 431:Src/BTLE.c    **** 
 432:Src/BTLE.c    ****   while (len--) {
 714              		.loc 1 432 0
 715 000c 28E0     		b	.L58
 716              	.LVL66:
 717              	.L61:
 718              	.LBB7:
 719              	.LBB8:
 720              	.LBB9:
 433:Src/BTLE.c    **** 
 434:Src/BTLE.c    ****     uint8_t d = *(buf++);
 435:Src/BTLE.c    **** 
 436:Src/BTLE.c    ****     for (uint8_t i = 1; i; i <<= 1, d >>= 1) {
 437:Src/BTLE.c    **** 
 438:Src/BTLE.c    ****       // save bit 23 (highest-value), left-shift the entire register by one
 439:Src/BTLE.c    ****       uint8_t t = dst[0] & 0x01;         
 440:Src/BTLE.c    ****       dst[0] >>= 1;
 441:Src/BTLE.c    ****       if (dst[1] & 0x01)
 442:Src/BTLE.c    ****       {
 443:Src/BTLE.c    ****         dst[0] |= 0x80; 
 444:Src/BTLE.c    ****       }
 445:Src/BTLE.c    **** 
 446:Src/BTLE.c    ****       dst[1] >>= 1;
 447:Src/BTLE.c    **** 
 448:Src/BTLE.c    ****       if (dst[2] & 0x01) 
 449:Src/BTLE.c    ****       {
 450:Src/BTLE.c    ****         dst[1] |= 0x80; 
 451:Src/BTLE.c    ****       }
 452:Src/BTLE.c    ****       dst[2] >>= 1;
 721              		.loc 1 452 0
 722 000e 5B08     		lsrs	r3, r3, #1
 723 0010 8B70     		strb	r3, [r1, #2]
 453:Src/BTLE.c    **** 
 454:Src/BTLE.c    ****       // if the bit just shifted out (former bit 23) and the incoming data
 455:Src/BTLE.c    ****       // bit are not equal (i.e. bit_out ^ bit_in == 1) => toggle tap bits
 456:Src/BTLE.c    ****       if (t != (d & 1)) {
 724              		.loc 1 456 0
 725 0012 04F00102 		and	r2, r4, #1
ARM GAS  /tmp/cckCRgnX.s 			page 22


 726 0016 BA42     		cmp	r2, r7
 727 0018 06D0     		beq	.L62
 457:Src/BTLE.c    ****         // toggle register tap bits (=XOR with 1) according to CRC polynom
 458:Src/BTLE.c    ****         dst[2] ^= 0xDA; // 0b11011010 inv. = 0b01011011 ^= x^6+x^4+x^3+x+1
 728              		.loc 1 458 0
 729 001a 83F0DA03 		eor	r3, r3, #218
 730 001e 8B70     		strb	r3, [r1, #2]
 459:Src/BTLE.c    ****         dst[1] ^= 0x60; // 0b01100000 inv. = 0b00000110 ^= x^10+x^9
 731              		.loc 1 459 0
 732 0020 4B78     		ldrb	r3, [r1, #1]	@ zero_extendqisi2
 733 0022 83F06003 		eor	r3, r3, #96
 734 0026 4B70     		strb	r3, [r1, #1]
 735              	.L62:
 736              	.LBE9:
 436:Src/BTLE.c    **** 
 737              		.loc 1 436 0 discriminator 2
 738 0028 4000     		lsls	r0, r0, #1
 739              	.LVL67:
 740 002a C0B2     		uxtb	r0, r0
 741              	.LVL68:
 742 002c 6408     		lsrs	r4, r4, #1
 743              	.LVL69:
 744              	.L59:
 436:Src/BTLE.c    **** 
 745              		.loc 1 436 0 is_stmt 0 discriminator 1
 746 002e A8B1     		cbz	r0, .L66
 747              	.LBB10:
 439:Src/BTLE.c    ****       dst[0] >>= 1;
 748              		.loc 1 439 0 is_stmt 1
 749 0030 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 750 0032 03F00107 		and	r7, r3, #1
 751              	.LVL70:
 440:Src/BTLE.c    ****       if (dst[1] & 0x01)
 752              		.loc 1 440 0
 753 0036 5A08     		lsrs	r2, r3, #1
 754 0038 0A70     		strb	r2, [r1]
 441:Src/BTLE.c    ****       {
 755              		.loc 1 441 0
 756 003a 4B78     		ldrb	r3, [r1, #1]	@ zero_extendqisi2
 757 003c 13F0010F 		tst	r3, #1
 758 0040 02D0     		beq	.L60
 443:Src/BTLE.c    ****       }
 759              		.loc 1 443 0
 760 0042 62F07F02 		orn	r2, r2, #127
 761 0046 0A70     		strb	r2, [r1]
 762              	.L60:
 446:Src/BTLE.c    **** 
 763              		.loc 1 446 0
 764 0048 5A08     		lsrs	r2, r3, #1
 765 004a 4A70     		strb	r2, [r1, #1]
 448:Src/BTLE.c    ****       {
 766              		.loc 1 448 0
 767 004c 8B78     		ldrb	r3, [r1, #2]	@ zero_extendqisi2
 768 004e 13F0010F 		tst	r3, #1
 769 0052 DCD0     		beq	.L61
 450:Src/BTLE.c    ****       }
 770              		.loc 1 450 0
ARM GAS  /tmp/cckCRgnX.s 			page 23


 771 0054 62F07F02 		orn	r2, r2, #127
 772 0058 4A70     		strb	r2, [r1, #1]
 773 005a D8E7     		b	.L61
 774              	.LVL71:
 775              	.L66:
 776              	.LBE10:
 777              	.LBE8:
 434:Src/BTLE.c    **** 
 778              		.loc 1 434 0
 779 005c 3346     		mov	r3, r6
 780              	.LBE7:
 432:Src/BTLE.c    **** 
 781              		.loc 1 432 0
 782 005e 2846     		mov	r0, r5
 783              	.LVL72:
 784              	.L58:
 785 0060 451E     		subs	r5, r0, #1
 786 0062 EDB2     		uxtb	r5, r5
 787              	.LVL73:
 788 0064 18B1     		cbz	r0, .L67
 789              	.LBB12:
 434:Src/BTLE.c    **** 
 790              		.loc 1 434 0
 791 0066 5E1C     		adds	r6, r3, #1
 792              	.LVL74:
 793 0068 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 794              	.LVL75:
 795              	.LBB11:
 436:Src/BTLE.c    **** 
 796              		.loc 1 436 0
 797 006a 0120     		movs	r0, #1
 798 006c DFE7     		b	.L59
 799              	.LVL76:
 800              	.L67:
 801              	.LBE11:
 802              	.LBE12:
 460:Src/BTLE.c    ****       }
 461:Src/BTLE.c    ****     }
 462:Src/BTLE.c    ****   }
 463:Src/BTLE.c    **** }
 803              		.loc 1 463 0
 804 006e F0BC     		pop	{r4, r5, r6, r7}
 805              	.LCFI22:
 806              		.cfi_restore 7
 807              		.cfi_restore 6
 808              		.cfi_restore 5
 809              		.cfi_restore 4
 810              		.cfi_def_cfa_offset 0
 811              	.LVL77:
 812 0070 7047     		bx	lr
 813              	.L69:
 814 0072 00BF     		.align	2
 815              	.L68:
 816 0074 00000000 		.word	buffer
 817              		.cfi_endproc
 818              	.LFE142:
 820              		.section	.text.advertise,"ax",%progbits
ARM GAS  /tmp/cckCRgnX.s 			page 24


 821              		.align	1
 822              		.global	advertise
 823              		.syntax unified
 824              		.thumb
 825              		.thumb_func
 826              		.fpu fpv4-sp-d16
 828              	advertise:
 829              	.LFB137:
 200:Src/BTLE.c    **** 	// name & total payload size
 830              		.loc 1 200 0
 831              		.cfi_startproc
 832              		@ args = 0, pretend = 0, frame = 8
 833              		@ frame_needed = 0, uses_anonymous_args = 0
 834              	.LVL78:
 835 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 836              	.LCFI23:
 837              		.cfi_def_cfa_offset 20
 838              		.cfi_offset 4, -20
 839              		.cfi_offset 5, -16
 840              		.cfi_offset 6, -12
 841              		.cfi_offset 7, -8
 842              		.cfi_offset 14, -4
 843 0002 83B0     		sub	sp, sp, #12
 844              	.LCFI24:
 845              		.cfi_def_cfa_offset 32
 846 0004 0746     		mov	r7, r0
 847 0006 0D46     		mov	r5, r1
 848 0008 1446     		mov	r4, r2
 202:Src/BTLE.c    **** 	uint8_t pls = 0;
 849              		.loc 1 202 0
 850 000a 324B     		ldr	r3, .L80
 851 000c 1E68     		ldr	r6, [r3]
 852 000e 3046     		mov	r0, r6
 853              	.LVL79:
 854 0010 FFF7FEFF 		bl	strlen
 855              	.LVL80:
 856 0014 C0B2     		uxtb	r0, r0
 857              	.LVL81:
 206:Src/BTLE.c    **** 	buffer.mac[1] = ((__TIME__[3]-0x30) << 4) | (__TIME__[4]-0x30);
 858              		.loc 1 206 0
 859 0016 304B     		ldr	r3, .L80+4
 860 0018 1122     		movs	r2, #17
 861 001a 9A70     		strb	r2, [r3, #2]
 207:Src/BTLE.c    **** 	buffer.mac[2] = ((__TIME__[0]-0x30) << 4) | (__TIME__[1]-0x30);
 862              		.loc 1 207 0
 863 001c 5422     		movs	r2, #84
 864 001e DA70     		strb	r2, [r3, #3]
 208:Src/BTLE.c    **** 	buffer.mac[3] = ((__DATE__[4]-0x30) << 4) | (__DATE__[5]-0x30);
 865              		.loc 1 208 0
 866 0020 1722     		movs	r2, #23
 867 0022 1A71     		strb	r2, [r3, #4]
 209:Src/BTLE.c    **** 	buffer.mac[4] = month(__DATE__);
 868              		.loc 1 209 0
 869 0024 2322     		movs	r2, #35
 870 0026 5A71     		strb	r2, [r3, #5]
 210:Src/BTLE.c    **** 	buffer.mac[5] = ((__DATE__[9]-0x30) << 4) | (__DATE__[10]-0x30) | 0xC0; // static random address s
 871              		.loc 1 210 0
ARM GAS  /tmp/cckCRgnX.s 			page 25


 872 0028 0422     		movs	r2, #4
 873 002a 9A71     		strb	r2, [r3, #6]
 211:Src/BTLE.c    **** 
 874              		.loc 1 211 0
 875 002c E222     		movs	r2, #226
 876 002e DA71     		strb	r2, [r3, #7]
 214:Src/BTLE.c    **** 	chunk(buffer,pls)->type = 0x01;  // chunk type: device flags
 877              		.loc 1 214 0
 878 0030 0222     		movs	r2, #2
 879 0032 1A72     		strb	r2, [r3, #8]
 215:Src/BTLE.c    **** 	chunk(buffer,pls)->data[0]= 0x05;  // flags: LE-only, limited discovery mode
 880              		.loc 1 215 0
 881 0034 0122     		movs	r2, #1
 882 0036 5A72     		strb	r2, [r3, #9]
 216:Src/BTLE.c    **** 	pls += 3;
 883              		.loc 1 216 0
 884 0038 0522     		movs	r2, #5
 885 003a 9A72     		strb	r2, [r3, #10]
 886              	.LVL82:
 220:Src/BTLE.c    **** 	chunk(buffer,pls)->type = 0x09;       // chunk type
 887              		.loc 1 220 0
 888 003c 421C     		adds	r2, r0, #1
 889 003e DA72     		strb	r2, [r3, #11]
 221:Src/BTLE.c    **** 	for (uint8_t i = 0; i < namelen; i++)
 890              		.loc 1 221 0
 891 0040 0922     		movs	r2, #9
 892 0042 1A73     		strb	r2, [r3, #12]
 893              	.LVL83:
 894              	.LBB13:
 222:Src/BTLE.c    **** 		chunk(buffer,pls)->data[i] = name[i];
 895              		.loc 1 222 0
 896 0044 0023     		movs	r3, #0
 897 0046 05E0     		b	.L71
 898              	.LVL84:
 899              	.L72:
 223:Src/BTLE.c    **** 	pls += namelen+2;
 900              		.loc 1 223 0 discriminator 3
 901 0048 F15C     		ldrb	r1, [r6, r3]	@ zero_extendqisi2
 902 004a 234A     		ldr	r2, .L80+4
 903 004c 1A44     		add	r2, r2, r3
 904 004e 5173     		strb	r1, [r2, #13]
 222:Src/BTLE.c    **** 		chunk(buffer,pls)->data[i] = name[i];
 905              		.loc 1 222 0 discriminator 3
 906 0050 0133     		adds	r3, r3, #1
 907              	.LVL85:
 908 0052 DBB2     		uxtb	r3, r3
 909              	.LVL86:
 910              	.L71:
 222:Src/BTLE.c    **** 		chunk(buffer,pls)->data[i] = name[i];
 911              		.loc 1 222 0 is_stmt 0 discriminator 1
 912 0054 8342     		cmp	r3, r0
 913 0056 F7D3     		bcc	.L72
 914              	.LBE13:
 224:Src/BTLE.c    **** 
 915              		.loc 1 224 0 is_stmt 1
 916 0058 0530     		adds	r0, r0, #5
 917              	.LVL87:
ARM GAS  /tmp/cckCRgnX.s 			page 26


 918 005a C6B2     		uxtb	r6, r0
 919              	.LVL88:
 227:Src/BTLE.c    **** 		chunk(buffer,pls)->size = buflen+1;  // chunk size
 920              		.loc 1 227 0
 921 005c 8CB1     		cbz	r4, .L73
 228:Src/BTLE.c    **** 		chunk(buffer,pls)->type = data_type; // chunk type
 922              		.loc 1 228 0
 923 005e 1F4B     		ldr	r3, .L80+8
 924              	.LVL89:
 925 0060 F018     		adds	r0, r6, r3
 926              	.LVL90:
 927 0062 621C     		adds	r2, r4, #1
 928 0064 9A55     		strb	r2, [r3, r6]
 229:Src/BTLE.c    **** 		for (uint8_t i = 0; i < buflen; i++)
 929              		.loc 1 229 0
 930 0066 4770     		strb	r7, [r0, #1]
 931              	.LVL91:
 932              	.LBB14:
 230:Src/BTLE.c    **** 			chunk(buffer,pls)->data[i] = ((uint8_t*)buf)[i];
 933              		.loc 1 230 0
 934 0068 0023     		movs	r3, #0
 935 006a 04E0     		b	.L74
 936              	.LVL92:
 937              	.L75:
 231:Src/BTLE.c    **** 		pls += buflen+2;
 938              		.loc 1 231 0 discriminator 3
 939 006c E95C     		ldrb	r1, [r5, r3]	@ zero_extendqisi2
 940 006e C218     		adds	r2, r0, r3
 941 0070 9170     		strb	r1, [r2, #2]
 230:Src/BTLE.c    **** 			chunk(buffer,pls)->data[i] = ((uint8_t*)buf)[i];
 942              		.loc 1 230 0 discriminator 3
 943 0072 0133     		adds	r3, r3, #1
 944              	.LVL93:
 945 0074 DBB2     		uxtb	r3, r3
 946              	.LVL94:
 947              	.L74:
 230:Src/BTLE.c    **** 			chunk(buffer,pls)->data[i] = ((uint8_t*)buf)[i];
 948              		.loc 1 230 0 is_stmt 0 discriminator 1
 949 0076 A342     		cmp	r3, r4
 950 0078 F8D3     		bcc	.L75
 951              	.LBE14:
 232:Src/BTLE.c    **** 	}
 952              		.loc 1 232 0 is_stmt 1
 953 007a 2644     		add	r6, r6, r4
 954              	.LVL95:
 955 007c F6B2     		uxtb	r6, r6
 956 007e 0236     		adds	r6, r6, #2
 957 0080 F6B2     		uxtb	r6, r6
 958              	.LVL96:
 959              	.L73:
 236:Src/BTLE.c    **** 		return false;
 960              		.loc 1 236 0
 961 0082 152E     		cmp	r6, #21
 962 0084 02D9     		bls	.L79
 237:Src/BTLE.c    **** 
 963              		.loc 1 237 0
 964 0086 0020     		movs	r0, #0
ARM GAS  /tmp/cckCRgnX.s 			page 27


 965              	.LVL97:
 966              	.L76:
 263:Src/BTLE.c    **** 
 967              		.loc 1 263 0
 968 0088 03B0     		add	sp, sp, #12
 969              	.LCFI25:
 970              		.cfi_remember_state
 971              		.cfi_def_cfa_offset 20
 972              		@ sp needed
 973 008a F0BD     		pop	{r4, r5, r6, r7, pc}
 974              	.LVL98:
 975              	.L79:
 976              	.LCFI26:
 977              		.cfi_restore_state
 240:Src/BTLE.c    **** 	buffer.pl_size = pls+6;    // set final payload size in header incl. MAC
 978              		.loc 1 240 0
 979 008c 124C     		ldr	r4, .L80+4
 980 008e 4223     		movs	r3, #66
 981 0090 2370     		strb	r3, [r4]
 241:Src/BTLE.c    **** 
 982              		.loc 1 241 0
 983 0092 B31D     		adds	r3, r6, #6
 984 0094 6370     		strb	r3, [r4, #1]
 985              	.LVL99:
 245:Src/BTLE.c    **** 
 986              		.loc 1 245 0
 987 0096 06F10800 		add	r0, r6, #8
 988 009a 2118     		adds	r1, r4, r0
 989 009c C0B2     		uxtb	r0, r0
 990 009e FFF7FEFF 		bl	crc
 991              	.LVL100:
 248:Src/BTLE.c    **** 	swapbuf( pls+11 );
 992              		.loc 1 248 0
 993 00a2 0B36     		adds	r6, r6, #11
 994              	.LVL101:
 995 00a4 F6B2     		uxtb	r6, r6
 996 00a6 3046     		mov	r0, r6
 997 00a8 FFF7FEFF 		bl	whiten
 998              	.LVL102:
 249:Src/BTLE.c    **** 
 999              		.loc 1 249 0
 1000 00ac 3046     		mov	r0, r6
 1001 00ae FFF7FEFF 		bl	swapbuf
 1002              	.LVL103:
 256:Src/BTLE.c    ****   spi_write_register(W_REGISTER_MASK + CONFIG, 1, &writing_byte);
 1003              		.loc 1 256 0
 1004 00b2 02AA     		add	r2, sp, #8
 1005 00b4 0223     		movs	r3, #2
 1006 00b6 02F8013D 		strb	r3, [r2, #-1]!
 257:Src/BTLE.c    **** 
 1007              		.loc 1 257 0
 1008 00ba 0121     		movs	r1, #1
 1009 00bc 2020     		movs	r0, #32
 1010 00be FFF7FEFF 		bl	spi_write_register
 1011              	.LVL104:
 259:Src/BTLE.c    ****   nRF24_CE_1(); // fire out the packet
 1012              		.loc 1 259 0
ARM GAS  /tmp/cckCRgnX.s 			page 28


 1013 00c2 2246     		mov	r2, r4
 1014 00c4 3146     		mov	r1, r6
 1015 00c6 A020     		movs	r0, #160
 1016 00c8 FFF7FEFF 		bl	spi_write_register
 1017              	.LVL105:
 260:Src/BTLE.c    **** 
 1018              		.loc 1 260 0
 1019 00cc FFF7FEFF 		bl	nRF24_CE_1
 1020              	.LVL106:
 262:Src/BTLE.c    **** }
 1021              		.loc 1 262 0
 1022 00d0 0120     		movs	r0, #1
 1023 00d2 D9E7     		b	.L76
 1024              	.L81:
 1025              		.align	2
 1026              	.L80:
 1027 00d4 00000000 		.word	name
 1028 00d8 00000000 		.word	buffer
 1029 00dc 08000000 		.word	buffer+8
 1030              		.cfi_endproc
 1031              	.LFE137:
 1033              		.section	.text.advertise_short,"ax",%progbits
 1034              		.align	1
 1035              		.global	advertise_short
 1036              		.syntax unified
 1037              		.thumb
 1038              		.thumb_func
 1039              		.fpu fpv4-sp-d16
 1041              	advertise_short:
 1042              	.LFB136:
 171:Src/BTLE.c    ****   return advertise(0xFF, buf, buflen);
 1043              		.loc 1 171 0
 1044              		.cfi_startproc
 1045              		@ args = 0, pretend = 0, frame = 0
 1046              		@ frame_needed = 0, uses_anonymous_args = 0
 1047              	.LVL107:
 1048 0000 08B5     		push	{r3, lr}
 1049              	.LCFI27:
 1050              		.cfi_def_cfa_offset 8
 1051              		.cfi_offset 3, -8
 1052              		.cfi_offset 14, -4
 172:Src/BTLE.c    **** }
 1053              		.loc 1 172 0
 1054 0002 0A46     		mov	r2, r1
 1055 0004 0146     		mov	r1, r0
 1056              	.LVL108:
 1057 0006 FF20     		movs	r0, #255
 1058              	.LVL109:
 1059 0008 FFF7FEFF 		bl	advertise
 1060              	.LVL110:
 173:Src/BTLE.c    **** 
 1061              		.loc 1 173 0
 1062 000c 08BD     		pop	{r3, pc}
 1063              		.cfi_endproc
 1064              	.LFE136:
 1066              		.section	.text.transmitPacket,"ax",%progbits
 1067              		.align	1
ARM GAS  /tmp/cckCRgnX.s 			page 29


 1068              		.global	transmitPacket
 1069              		.syntax unified
 1070              		.thumb
 1071              		.thumb_func
 1072              		.fpu fpv4-sp-d16
 1074              	transmitPacket:
 1075              	.LFB140:
 306:Src/BTLE.c    ****   uint8_t pls = buffer.pl_size - 6;
 1076              		.loc 1 306 0
 1077              		.cfi_startproc
 1078              		@ args = 0, pretend = 0, frame = 72
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080 0000 70B5     		push	{r4, r5, r6, lr}
 1081              	.LCFI28:
 1082              		.cfi_def_cfa_offset 16
 1083              		.cfi_offset 4, -16
 1084              		.cfi_offset 5, -12
 1085              		.cfi_offset 6, -8
 1086              		.cfi_offset 14, -4
 1087 0002 92B0     		sub	sp, sp, #72
 1088              	.LCFI29:
 1089              		.cfi_def_cfa_offset 88
 307:Src/BTLE.c    ****   // calculate CRC over header+MAC+payload, append after payload
 1090              		.loc 1 307 0
 1091 0004 1C4B     		ldr	r3, .L88
 1092 0006 5E78     		ldrb	r6, [r3, #1]	@ zero_extendqisi2
 1093 0008 B51F     		subs	r5, r6, #6
 1094 000a EDB2     		uxtb	r5, r5
 1095              	.LVL111:
 310:Src/BTLE.c    ****   
 1096              		.loc 1 310 0
 1097 000c 05F10801 		add	r1, r5, #8
 1098 0010 B01C     		adds	r0, r6, #2
 1099 0012 1944     		add	r1, r1, r3
 1100 0014 C0B2     		uxtb	r0, r0
 1101 0016 FFF7FEFF 		bl	crc
 1102              	.LVL112:
 313:Src/BTLE.c    ****   swapbuf( pls+11 );
 1103              		.loc 1 313 0
 1104 001a 0536     		adds	r6, r6, #5
 1105 001c F6B2     		uxtb	r6, r6
 1106 001e 3046     		mov	r0, r6
 1107 0020 FFF7FEFF 		bl	whiten
 1108              	.LVL113:
 314:Src/BTLE.c    ****   // flush buffers and send
 1109              		.loc 1 314 0
 1110 0024 3046     		mov	r0, r6
 1111 0026 FFF7FEFF 		bl	swapbuf
 1112              	.LVL114:
 321:Src/BTLE.c    **** 	for (int i = 0; i < pls+11; ++i) {
 1113              		.loc 1 321 0
 1114 002a 1448     		ldr	r0, .L88+4
 1115 002c FFF7FEFF 		bl	serial_print
 1116              	.LVL115:
 1117              	.LBB15:
 322:Src/BTLE.c    **** 		sprintf(msg, "%#02x", outbuf[i]);
 1118              		.loc 1 322 0
ARM GAS  /tmp/cckCRgnX.s 			page 30


 1119 0030 0024     		movs	r4, #0
 1120 0032 09E0     		b	.L85
 1121              	.LVL116:
 1122              	.L86:
 323:Src/BTLE.c    **** 		serial_print(msg);
 1123              		.loc 1 323 0 discriminator 3
 1124 0034 104B     		ldr	r3, .L88
 1125 0036 1A5D     		ldrb	r2, [r3, r4]	@ zero_extendqisi2
 1126 0038 1149     		ldr	r1, .L88+8
 1127 003a 02A8     		add	r0, sp, #8
 1128 003c FFF7FEFF 		bl	sprintf
 1129              	.LVL117:
 324:Src/BTLE.c    **** 	}
 1130              		.loc 1 324 0 discriminator 3
 1131 0040 02A8     		add	r0, sp, #8
 1132 0042 FFF7FEFF 		bl	serial_print
 1133              	.LVL118:
 322:Src/BTLE.c    **** 		sprintf(msg, "%#02x", outbuf[i]);
 1134              		.loc 1 322 0 discriminator 3
 1135 0046 0134     		adds	r4, r4, #1
 1136              	.LVL119:
 1137              	.L85:
 322:Src/BTLE.c    **** 		sprintf(msg, "%#02x", outbuf[i]);
 1138              		.loc 1 322 0 is_stmt 0 discriminator 1
 1139 0048 05F10B03 		add	r3, r5, #11
 1140 004c 9C42     		cmp	r4, r3
 1141 004e F1DB     		blt	.L86
 1142              	.LBE15:
 327:Src/BTLE.c    **** 
 1143              		.loc 1 327 0 is_stmt 1
 1144 0050 02A8     		add	r0, sp, #8
 1145 0052 FFF7FEFF 		bl	serial_print
 1146              	.LVL120:
 330:Src/BTLE.c    ****   spi_write_register(W_REGISTER_MASK + CONFIG, 1, &writing_byte);
 1147              		.loc 1 330 0
 1148 0056 12AA     		add	r2, sp, #72
 1149 0058 0223     		movs	r3, #2
 1150 005a 02F8413D 		strb	r3, [r2, #-65]!
 331:Src/BTLE.c    **** 
 1151              		.loc 1 331 0
 1152 005e 0121     		movs	r1, #1
 1153 0060 2020     		movs	r0, #32
 1154 0062 FFF7FEFF 		bl	spi_write_register
 1155              	.LVL121:
 333:Src/BTLE.c    ****   nRF24_CE_1(); // fire out the packet
 1156              		.loc 1 333 0
 1157 0066 044A     		ldr	r2, .L88
 1158 0068 3146     		mov	r1, r6
 1159 006a A020     		movs	r0, #160
 1160 006c FFF7FEFF 		bl	spi_write_register
 1161              	.LVL122:
 334:Src/BTLE.c    **** }
 1162              		.loc 1 334 0
 1163 0070 FFF7FEFF 		bl	nRF24_CE_1
 1164              	.LVL123:
 335:Src/BTLE.c    **** 
 1165              		.loc 1 335 0
ARM GAS  /tmp/cckCRgnX.s 			page 31


 1166 0074 12B0     		add	sp, sp, #72
 1167              	.LCFI30:
 1168              		.cfi_def_cfa_offset 16
 1169              		@ sp needed
 1170 0076 70BD     		pop	{r4, r5, r6, pc}
 1171              	.LVL124:
 1172              	.L89:
 1173              		.align	2
 1174              	.L88:
 1175 0078 00000000 		.word	buffer
 1176 007c 00000000 		.word	.LC1
 1177 0080 14000000 		.word	.LC2
 1178              		.cfi_endproc
 1179              	.LFE140:
 1181              		.global	month_lookup
 1182              		.global	frequency
 1183              		.global	channel
 1184              		.comm	name,4,4
 1185              		.comm	current,1,1
 1186              		.comm	buffer,32,4
 1187              		.section	.rodata
 1188              		.align	2
 1189              		.set	.LANCHOR1,. + 0
 1190              	.LC0:
 1191 0000 6B       		.byte	107
 1192 0001 7D       		.byte	125
 1193 0002 91       		.byte	-111
 1194 0003 71       		.byte	113
 1195              		.section	.rodata.channel,"a",%progbits
 1196              		.align	2
 1197              		.set	.LANCHOR2,. + 0
 1200              	channel:
 1201 0000 25       		.byte	37
 1202 0001 26       		.byte	38
 1203 0002 27       		.byte	39
 1204              		.section	.rodata.frequency,"a",%progbits
 1205              		.align	2
 1206              		.set	.LANCHOR0,. + 0
 1209              	frequency:
 1210 0000 02       		.byte	2
 1211 0001 1A       		.byte	26
 1212 0002 50       		.byte	80
 1213              		.section	.rodata.month_lookup,"a",%progbits
 1214              		.align	2
 1217              	month_lookup:
 1218 0000 00       		.byte	0
 1219 0001 06       		.byte	6
 1220 0002 00       		.byte	0
 1221 0003 04       		.byte	4
 1222 0004 00       		.byte	0
 1223 0005 01       		.byte	1
 1224 0006 00       		.byte	0
 1225 0007 11       		.byte	17
 1226 0008 00       		.byte	0
 1227 0009 08       		.byte	8
 1228 000a 00       		.byte	0
 1229 000b 00       		.byte	0
ARM GAS  /tmp/cckCRgnX.s 			page 32


 1230 000c 03       		.byte	3
 1231 000d 00       		.byte	0
 1232 000e 00       		.byte	0
 1233 000f 00       		.byte	0
 1234 0010 12       		.byte	18
 1235 0011 02       		.byte	2
 1236 0012 10       		.byte	16
 1237 0013 05       		.byte	5
 1238 0014 09       		.byte	9
 1239 0015 00       		.byte	0
 1240 0016 01       		.byte	1
 1241 0017 07       		.byte	7
 1242              		.section	.rodata.transmitPacket.str1.4,"aMS",%progbits,1
 1243              		.align	2
 1244              	.LC1:
 1245 0000 7072696E 		.ascii	"printing outbuf: \000"
 1245      74696E67 
 1245      206F7574 
 1245      6275663A 
 1245      2000
 1246 0012 0000     		.space	2
 1247              	.LC2:
 1248 0014 25233032 		.ascii	"%#02x\000"
 1248      7800
 1249              		.text
 1250              	.Letext0:
 1251              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1252              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 1253              		.file 4 "Drivers/CMSIS/Include/core_cm4.h"
 1254              		.file 5 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/system_stm32f4xx.h"
 1255              		.file 6 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f401xe.h"
 1256              		.file 7 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 1257              		.file 8 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 1258              		.file 9 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 1259              		.file 10 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 1260              		.file 11 "/usr/include/newlib/sys/lock.h"
 1261              		.file 12 "/usr/include/newlib/sys/_types.h"
 1262              		.file 13 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 1263              		.file 14 "/usr/include/newlib/sys/reent.h"
 1264              		.file 15 "Inc/nRF24.h"
 1265              		.file 16 "/usr/include/newlib/stdlib.h"
 1266              		.file 17 "Inc/BTLE.h"
 1267              		.file 18 "/usr/include/newlib/stdio.h"
 1268              		.file 19 "/usr/include/newlib/string.h"
ARM GAS  /tmp/cckCRgnX.s 			page 33


DEFINED SYMBOLS
                            *ABS*:0000000000000000 BTLE.c
     /tmp/cckCRgnX.s:18     .text.swapbuf:0000000000000000 $t
     /tmp/cckCRgnX.s:25     .text.swapbuf:0000000000000000 swapbuf
     /tmp/cckCRgnX.s:137    .text.swapbuf:0000000000000070 $d
                            *COM*:0000000000000020 buffer
     /tmp/cckCRgnX.s:142    .text.begin:0000000000000000 $t
     /tmp/cckCRgnX.s:149    .text.begin:0000000000000000 begin
     /tmp/cckCRgnX.s:258    .text.begin:0000000000000098 $d
                            *COM*:0000000000000004 name
                            *COM*:0000000000000001 current
     /tmp/cckCRgnX.s:266    .text.setChannel:0000000000000000 $t
     /tmp/cckCRgnX.s:273    .text.setChannel:0000000000000000 setChannel
     /tmp/cckCRgnX.s:325    .text.setChannel:0000000000000030 $d
     /tmp/cckCRgnX.s:331    .text.hopChannel:0000000000000000 $t
     /tmp/cckCRgnX.s:338    .text.hopChannel:0000000000000000 hopChannel
     /tmp/cckCRgnX.s:386    .text.hopChannel:0000000000000034 $d
     /tmp/cckCRgnX.s:392    .text.addChunk:0000000000000000 $t
     /tmp/cckCRgnX.s:399    .text.addChunk:0000000000000000 addChunk
     /tmp/cckCRgnX.s:486    .text.addChunk:0000000000000040 $d
     /tmp/cckCRgnX.s:492    .text.preparePacket:0000000000000000 $t
     /tmp/cckCRgnX.s:499    .text.preparePacket:0000000000000000 preparePacket
     /tmp/cckCRgnX.s:577    .text.preparePacket:0000000000000054 $d
     /tmp/cckCRgnX.s:583    .text.whiten:0000000000000000 $t
     /tmp/cckCRgnX.s:590    .text.whiten:0000000000000000 whiten
     /tmp/cckCRgnX.s:675    .text.whiten:0000000000000044 $d
     /tmp/cckCRgnX.s:682    .text.crc:0000000000000000 $t
     /tmp/cckCRgnX.s:689    .text.crc:0000000000000000 crc
     /tmp/cckCRgnX.s:816    .text.crc:0000000000000074 $d
     /tmp/cckCRgnX.s:821    .text.advertise:0000000000000000 $t
     /tmp/cckCRgnX.s:828    .text.advertise:0000000000000000 advertise
     /tmp/cckCRgnX.s:1027   .text.advertise:00000000000000d4 $d
     /tmp/cckCRgnX.s:1034   .text.advertise_short:0000000000000000 $t
     /tmp/cckCRgnX.s:1041   .text.advertise_short:0000000000000000 advertise_short
     /tmp/cckCRgnX.s:1067   .text.transmitPacket:0000000000000000 $t
     /tmp/cckCRgnX.s:1074   .text.transmitPacket:0000000000000000 transmitPacket
     /tmp/cckCRgnX.s:1175   .text.transmitPacket:0000000000000078 $d
     /tmp/cckCRgnX.s:1217   .rodata.month_lookup:0000000000000000 month_lookup
     /tmp/cckCRgnX.s:1209   .rodata.frequency:0000000000000000 frequency
     /tmp/cckCRgnX.s:1200   .rodata.channel:0000000000000000 channel
     /tmp/cckCRgnX.s:1188   .rodata:0000000000000000 $d
     /tmp/cckCRgnX.s:1196   .rodata.channel:0000000000000000 $d
     /tmp/cckCRgnX.s:1205   .rodata.frequency:0000000000000000 $d
     /tmp/cckCRgnX.s:1214   .rodata.month_lookup:0000000000000000 $d
     /tmp/cckCRgnX.s:1243   .rodata.transmitPacket.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
nRF24_CE_0
nRF24_verified_write_register
spi_delay
spi_write_register
strlen
nRF24_CE_1
serial_print
sprintf
